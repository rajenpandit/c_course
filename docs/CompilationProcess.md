# Compilation Process

Compilation process in **C** involves different steps which are as follows:

## Preprocessor  
The lines in your code which begins with # is called **Preprocessor directives**.

```c
    #include "sum.h"
    #define ABC 10
    int main() {
        int s = sum(2, ABC);
        return 0;
    }
```
In this example, preprocessor directives are `#include "Sum.h"` and `#define ABC 10`.  
When compilation process starts, at first it will run preprocessor. So, after preprocessing the code will look like this:  
```c
    int sub(int a, int b);
    int sum(int, int);
    int main() {
        int s = sum(2, 10);
        return 0;
    }
```
`Note:` All those line which starts with `#` is now removed and `#include "Sum.h"` is replaced with content of file [sum.h](../sum.h). The file [Sum.h](../sum.h) internally includes [math.h](../math.h), so again `#include "math.h"` is replaced with the content of [math.h](../math.h). Also, occurence of `ABC` is replaced with 10 which is from directive `#define ABC 10` 

In `gcc` like compiler the compilation processes can be interrupted after preprocessor by using following command.  
```sh
gcc -E helloworld.c -o helloworld.cc
``` 

## Compiler 

When stage-1 that is Preprocessing is completed the output is used by compiler to compile the Source Code (Human Redable Format) to Object Code (Binary Data).

Compilation process validates the Syntax and Function Signature. The process will throw error if there is a syntax error or if it finds any function call whose declaration is not available.  

The below example will throw error since function `sum` is not declared before calling it. 
```c
int main() {
int s = sum(2, ABC);
return 0;
}
```
The error can be fixed by declaring the function signature.
```c
int sum(int a, int b); //function declaration
// here parameter name is not mandatory, it can also be written as: int sum(int, int);

int main() {
int s = sum(2, ABC);
return 0;
}
```
However, this will lead to a linking error if function definition is not provided during linking process. 

The Compiler part can be further divided into two stages that is `Generating Assembly Code` from source and then running `Assembler` to generate Object Code. (***`NOTE:` We will discuss this***)

Command to compile a source code file `helloworld.c`.  

```sh
gcc -c helloworld.c
```
The above command will create `helloworld.o` file. This file will contain object code in binary format, so if you try to open this file in any text editor you will not able to see readable text. But we can decode this file and produce one readable file using `objdump` command.
```sh
objdump  --disassemble helloworld.o
```
This will produce following output
~~~
helloworld.o:   file format mach-o arm64

Disassembly of section __TEXT,__text:

0000000000000000 <ltmp0>:
       0: ff 83 00 d1   sub     sp, sp, #32
       4: fd 7b 01 a9   stp     x29, x30, [sp, #16]
       8: fd 43 00 91   add     x29, sp, #16
       c: 08 00 80 52   mov     w8, #0
      10: e8 07 00 b9   str     w8, [sp, #4]
      14: bf c3 1f b8   stur    wzr, [x29, #-4]
      18: 40 00 80 52   mov     w0, #2
      1c: 81 00 80 52   mov     w1, #4
      20: 00 00 00 94   bl      0x20 <ltmp0+0x20>
      24: e8 03 00 aa   mov     x8, x0
      28: e0 07 40 b9   ldr     w0, [sp, #4]
      2c: e8 0b 00 b9   str     w8, [sp, #8]
      30: fd 7b 41 a9   ldp     x29, x30, [sp, #16]
      34: ff 83 00 91   add     sp, sp, #32
      38: c0 03 5f d6   ret
~~~
Object code for `sum.c`
```sh
gcc -c sum.c
```
```sh
objdump  --disassemble sum.o
```
~~~
sum.o:  file format mach-o arm64

Disassembly of section __TEXT,__text:

0000000000000000 <ltmp0>:
       0: ff 43 00 d1   sub     sp, sp, #16
       4: e0 0f 00 b9   str     w0, [sp, #12]
       8: e1 0b 00 b9   str     w1, [sp, #8]
       c: e8 0f 40 b9   ldr     w8, [sp, #12]
      10: e9 0b 40 b9   ldr     w9, [sp, #8]
      14: 00 01 09 0b   add     w0, w8, w9
      18: ff 43 00 91   add     sp, sp, #16
      1c: c0 03 5f d6   ret
~~~

Here you can see the actual binary instructions at left side and its corresponding assembly instruction in right side. The leftmost column represents the relative address which will be updated later during linking process.

## Linker

Once object files are generated by compiler, the linker will resolve the symbols and link, like `function calls` to `function definition`. 
In this process, the object file should contain all the function definitions which are called from other places. Otherwise linker will throw error. 
For example, if you try to generate executable using `helloworld.o` file only where definition of function `sum` is not available, linker will throw error.
```sh
gcc helloworld.o -o helloworld
```
Error:
~~~
Undefined symbols for architecture arm64:
  "_sum", referenced from:
      _main in helloworld.o
ld: symbol(s) not found for architecture arm64
~~~

To resolve this error, you will have to provide the object file where definition of function sum is available. In this case it is in file `sum.o`.  
```sh
gcc helloworld.o sum.o -o helloworld
```
Once sum.o file is provided, the linker will resolve the address of sum and it will replace in all the placess where function sum is called.

Let see what is present in executable file `helloworld`

```sh
objdump  --disassemble helloworld
```
~~~
helloworld:     file format mach-o arm64

Disassembly of section __TEXT,__text:

0000000100003f54 <_main>:
100003f54: ff 83 00 d1  sub     sp, sp, #32
100003f58: fd 7b 01 a9  stp     x29, x30, [sp, #16]
100003f5c: fd 43 00 91  add     x29, sp, #16
100003f60: 08 00 80 52  mov     w8, #0
100003f64: e8 07 00 b9  str     w8, [sp, #4]
100003f68: bf c3 1f b8  stur    wzr, [x29, #-4]
100003f6c: 40 00 80 52  mov     w0, #2
100003f70: 81 00 80 52  mov     w1, #4
100003f74: 07 00 00 94  bl      0x100003f90 <_sum>
100003f78: e8 03 00 aa  mov     x8, x0
100003f7c: e0 07 40 b9  ldr     w0, [sp, #4]
100003f80: e8 0b 00 b9  str     w8, [sp, #8]
100003f84: fd 7b 41 a9  ldp     x29, x30, [sp, #16]
100003f88: ff 83 00 91  add     sp, sp, #32
100003f8c: c0 03 5f d6  ret

0000000100003f90 <_sum>:
100003f90: ff 43 00 d1  sub     sp, sp, #16
100003f94: e0 0f 00 b9  str     w0, [sp, #12]
100003f98: e1 0b 00 b9  str     w1, [sp, #8]
100003f9c: e8 0f 40 b9  ldr     w8, [sp, #12]
100003fa0: e9 0b 40 b9  ldr     w9, [sp, #8]
100003fa4: 00 01 09 0b  add     w0, w8, w9
100003fa8: ff 43 00 91  add     sp, sp, #16
100003fac: c0 03 5f d6  ret
~~~

Here, you can search for `_sum`, you will find out that the address of `_sum (100003f90)` is placed in `_main` function by the linker where `_sum` is invoked.  
Also try comparing the **objdump** of `helloworld.o`, `sum.o` and `helloworld`. You will find that in executable file `helloworld` the addresses are recalculated by the linker and updated. 


         